<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Scene-场景属性&方法</title>
	<style>
		* {
			margin: 0;
		}

		canvas {
			display: block;
			width: 100%;
			height: 100%;
		}
	</style>
</head>

<body>
	<!-- Import maps polyfill -->
	<!-- Remove this when import maps will be widely supported -->
	<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

	<script type="importmap">
		{
			"imports": {
				"three": "../../libs/three.module.js"
			}
		}
	</script>

	<script type="module">
		import {
			Scene,
			PerspectiveCamera,
			WebGLRenderer,
			AmbientLight,
      PointLight,
      DirectionalLight,
			SpotLight,
			MeshPhongMaterial,
			MeshLambertMaterial,
      ShaderMaterial,
      MeshBasicMaterial,
			Mesh,
			BoxGeometry,
      SphereBufferGeometry,
			PlaneGeometry,
			Fog,
			Color,
      Object3D,
      SphereGeometry,
      MeshStandardMaterial,
      MeshPhysicalMaterial,
      TextureLoader,
      CameraHelper,
      AxesHelper,
      BoxHelper,
      Vector2,
      RepeatWrapping
		} from 'three';
		import { OrbitControls } from '../../libs/jsm/controls/OrbitControls.js';
		import { GUI } from '../../libs/jsm/libs/lil-gui.module.min.js';
		


		let scene, camera, renderer;

		scene = new Scene();

		camera = new PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 10000);
    camera.position.set(0, 0, 700);
		renderer = new WebGLRenderer({ antialias: true });
		renderer.setPixelRatio(window.devicePixelRatio);
		renderer.setSize(window.innerWidth, window.innerHeight);
		document.body.appendChild(renderer.domElement);

    const orbit = new OrbitControls( camera, renderer.domElement );

    // const helper = new CameraHelper(camera);
    // scene.add(helper);


    const axesHelper = new AxesHelper(1000); 
    scene.add(axesHelper);


    // const ambientLight = new AmbientLight(0xFFFFFF);
    // ambientLight.position.set(0, 0, 700);
		// scene.add(ambientLight);

    // const sun = new SpotLight(0x393939, 2.5);
    // sun.position.set(-15, 10, 21);
    // scene.add(sun);

    const light = new DirectionalLight(0xffffff, 1);
    light.position.set(0, 0, 700);
    scene.add(light);



    const loader = new TextureLoader()
    const bgTexture = loader.load('../img/stars.jpg');
    scene.background = bgTexture;


    function bgTextureResize() {
      const canvasAspect = window.innerWidth / window.innerHeight;
      const imageAspect = bgTexture.image ? bgTexture.image.width / bgTexture.image.height : 1;
      const aspect = imageAspect / canvasAspect;
      
      bgTexture.offset.x = aspect > 1 ? (1 - 1 / aspect) / 2 : 0;
      bgTexture.repeat.x = aspect > 1 ? 1 / aspect : 1;
      
      bgTexture.offset.y = aspect > 1 ? 0 : (1 - aspect) / 2;
      bgTexture.repeat.y = aspect > 1 ? 1 : aspect;
    }

    
    let earthOrbit = new Object3D();
    let earth

    let earthGgeometry = new SphereGeometry(100, 32, 32);
    let earthMaterial = new MeshPhongMaterial( {
      map: loader.load( '../img/2_no_clouds_8k_recolor.jpg'),
      // 镜面反射
      specularMap: loader.load('../img/Earth_Specular_1024.jpg'),
      // 用于创建凹凸贴图的纹理
      bumpMap: loader.load('../img/normal_8k.jpg'),
      normalScale: new Vector2(1, 1),
      specular: 0x010203,
      shininess: 4,
      reflectivity: 0.3,
      refractionRatio: 0.3
    } );
    earth = new Mesh( earthGgeometry, earthMaterial );

    //顶点着色器
    var VSHADER_SOURCE = `
      varying vec2 v_Uv;   
      void main () {
        v_Uv = uv;       //顶点纹理坐标
        gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4( position, 1.0 );
      }
    `

    //片元着色器
    var FSHADER_SOURCE = `
      uniform float time;      //时间变量
      uniform sampler2D fTexture;    //大气纹理图像
      uniform sampler2D nTexture;    //噪声纹理图像
      varying vec2 v_Uv;              //片元纹理坐标
      void main () {
        vec2 new_Uv= v_Uv + vec2( 0, 0.02 ) * time;   //向量加法，根据时间变量计算新的纹理坐标
        
        //利用噪声随机使纹理坐标随机化
        vec4 noise_Color = texture2D( nTexture, new_Uv );    
        new_Uv.x += noise_Color.r * 0.2;
        new_Uv.y += noise_Color.g * 0.2;
        
        gl_FragColor = texture2D( fTexture, new_Uv );  //提取大气纹理图像的颜色值（纹素）
      }
    `

    var cloudsTexture = loader.load( '../img/fair_clouds_8k.jpg')
    cloudsTexture.wrapS = RepeatWrapping
    cloudsTexture.wrapT = RepeatWrapping

    var noiseTexture = loader.load('../img/noise.png')
    noiseTexture.wrapS = RepeatWrapping
    noiseTexture.wrapT = RepeatWrapping

    var flowMaterial = new ShaderMaterial({
      uniforms: {
        fTexture: {
          value: cloudsTexture,  
        },
        nTexture: {
          value: noiseTexture,
        },
        time: {
          value: 0.0
        },
      },
      // 顶点着色器
      vertexShader: VSHADER_SOURCE,
      // 片元着色器
      fragmentShader: FSHADER_SOURCE,
      transparent: true
    })

    let earthGgeometry2 = new SphereGeometry(100.01, 32, 32);

    var earth2 = new Mesh( earthGgeometry2, flowMaterial );
    
    const boxHelper = new BoxHelper(earth);
    scene.add(boxHelper);
    
    earthOrbit.add(earth);

    earthOrbit.add(earth2);

    scene.add(earthOrbit);
 
    




		function render(time) {
      time = time * 0.0005;
      earthOrbit.rotation.y = time;
			requestAnimationFrame(render);
			renderer.render(scene, camera);
		}
		window.addEventListener('resize', function () {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

      bgTextureResize()

			renderer.setSize(window.innerWidth, window.innerHeight);
		}, false);


		render();

	</script>
</body>

</html>